package com.thinkive.fxc.ismp.bus.business.util;

import java.util.Calendar;
import java.util.Date;
import java.util.Map;
import java.util.Map.Entry;

import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;

import com.thinkive.base.config.Configuration;
import com.thinkive.base.exception.BusinessException;
import com.thinkive.base.jdbc.DataRow;
import com.thinkive.base.util.DateHelper;
import com.thinkive.base.util.RandomHelper;
import com.thinkive.base.util.SpringHelper;
import com.thinkive.base.util.StringHelper;
import com.thinkive.fxc.ismp.bus.base.basicdata.contants.BasicServiceBeanIdConstants;
import com.thinkive.fxc.ismp.bus.base.basicdata.service.CacheService;
import com.thinkive.fxc.ismp.bus.base.business.constants.BusinessServiceBeanIdConstants;
import com.thinkive.fxc.ismp.bus.base.business.model.SmsModelModel;
import com.thinkive.fxc.ismp.bus.base.business.model.SmsSendLogModel;
import com.thinkive.fxc.ismp.bus.base.business.service.SmsModelService;
import com.thinkive.fxc.ismp.bus.base.business.service.SmsSendLogService;
import com.thinkive.fxc.ismp.bus.base.constants.DictionaryConstants;
import com.thinkive.fxc.ismp.bus.base.constants.ErrorCodeSystem;
import com.thinkive.fxc.ismp.bus.base.constants.SystemConstants;
import com.thinkive.fxc.ismp.bus.business.constants.BusinessBeanIdConstants;
import com.thinkive.fxc.ismp.bus.business.service.SmsSendService;
import com.thinkive.redis.client.JedisClient;
import com.thinkive.server.InvokeException;

public class SmsUtils
{
	
	private static Logger logger = Logger.getLogger(SmsUtils.class);
	
	/**
	 * @描述：获取新验证码
	 * @作者：刘恺
	 * @时间：2016年8月26日 下午10:39:27
	 * @param sms_type
	 * @param mobile_no
	 * @return
	 * @throws InvokeException
	 */
	public static String getNewCode(String sms_type, String mobile_no) throws InvokeException
	{
		CacheService cacheService = SpringHelper.getBean(BasicServiceBeanIdConstants.SERVICE_ID_CACHE, CacheService.class);
		String key = sms_type + "_" + mobile_no;
		String saved_code = "";
		
		//无短信缓存或者已超过短信缓存时间，生成新的短信
		RandomHelper random = new RandomHelper();
		String code = random.identifyCodeBuilder(DictionaryConstants.VERIFICATION_CODE_LENGTH);
		String code_time = code + "_" + DateHelper.formatDate(new Date(), DateHelper.pattern_time);
		cacheService.setCache(key, code_time, Configuration.getInt(SystemConstants.CONFIG_KEY_SMS_SMSCODESAVE_TIME));
		
		String savedCodetime = (String) cacheService.getCache(key);
		if (StringHelper.isBlank(savedCodetime))
		{
			throw new BusinessException(ErrorCodeSystem.SMS_ERROR_CANNOTINSERTCODE);
		}
		String codetime[] = savedCodetime.split("_");
		saved_code = codetime[0];
		if (StringHelper.isEmpty(saved_code))
		{
			throw new BusinessException(ErrorCodeSystem.SMS_ERROR_CODEPRDERROR);
		}
		return saved_code;
	}
	
	/**
	 * @描述：校验短信验证码
	 * @作者：刘恺
	 * @时间：2016年8月26日 下午10:39:13
	 * @param mobile
	 * @param mobile_code
	 * @param sms_type
	 * @return
	 * @throws InvokeException
	 */
	public static boolean checkMobileCode(String mobile, String mobile_code, String sms_type) throws InvokeException
	{
		CacheService cacheService = SpringHelper.getBean(BasicServiceBeanIdConstants.SERVICE_ID_CACHE, CacheService.class);
		String sendFlag = Configuration.getString(SystemConstants.CONFIG_KEY_SMS_SMSVALIDATE);
		boolean flag = true;
		if (DictionaryConstants.BOL_FALSE.equals(sendFlag))
		{
			return flag;
		}
		String key = sms_type + "_" + mobile;
		String saved_codetime = (String) cacheService.getCache(key);
		
		//记录登陆日志
		if (StringHelper.isEmpty(saved_codetime))
		{
			throw new BusinessException(ErrorCodeSystem.SMS_ERROR_TIMEEXPIRED);
		}
		String saved_code = saved_codetime.split("_")[0];
		if (!mobile_code.equals(saved_code))
		{
			throw new BusinessException(ErrorCodeSystem.SMS_ERROR_ERRORCODE);
		}
		return flag;
	}
	
	/**
	 * 描述：根据模版信息发送短信
	 * @author 刘恺
	 * @created 2015年9月23日 下午2:22:10
	 * @since 
	 * @param smsModel   短信模版
	 * @param mobile_no  手机号
	 * @return
	 * @throws Exception
	 */
	public static boolean sendByModel(SmsModelModel smsModel, String mobile_no, Long user_id, String business_id, String ip, String mac,String business_code) throws Exception
	{
		//获取短信内容
		boolean flag = true;
		SmsSendService smsSender = SpringHelper.getBean(BusinessBeanIdConstants.SERVICE_ID_SMSSEND, SmsSendService.class);
		SmsSendLogModel smsSendLogData = new SmsSendLogModel();
		smsSendLogData.setModelId(smsModel.getId());
		smsSendLogData.setMobile(mobile_no);
		smsSendLogData.setContent(smsModel.getSmsMessage());
		smsSendLogData.setBusinessId(business_id);
		smsSendLogData.setUserId(user_id);
		smsSendLogData.setBusinessCode(business_code);
		smsSendLogData.setSendFlag(DictionaryConstants.BOL_TRUE);
		smsSendLogData.setIp(ip);
		smsSendLogData.setMac(mac);
		smsSendLogData.setDescription("发送成功");
		SmsSendLogService smsSendLogService = SpringHelper.getBean(BusinessServiceBeanIdConstants.SERVICE_ID_SMSSENDLOG, SmsSendLogService.class);
		try
		{
			flag = smsSender.sendSMS(mobile_no, smsModel);
			JedisClient jedisClient = new JedisClient("web");
			//缓存中添加发送次数
			String userIdCacheKey = "ismp|smssend|" + user_id + "|" + smsModel.getSmsType();
			//查询用户当前短信类型发送次数
			Long userCurrSendTime = jedisClient.incr(userIdCacheKey);
			if (1 == userCurrSendTime)
			{
				Calendar calendar = Calendar.getInstance();
				calendar.set(Calendar.HOUR, 23);
				calendar.set(Calendar.MINUTE, 59);
				calendar.set(Calendar.SECOND, 59);
				jedisClient.expireAt(userIdCacheKey, calendar.getTime());
			}
			//查询IP当前短信类型发送次数
			String ipCacheKey = "ismp|smssend|" + ip + "|" + smsModel.getSmsType();
			Long ipCurrSendTime = jedisClient.incr(ipCacheKey);
			if (1 == ipCurrSendTime)
			{
				Calendar calendar = Calendar.getInstance();
				calendar.set(Calendar.HOUR, 23);
				calendar.set(Calendar.MINUTE, 59);
				calendar.set(Calendar.SECOND, 59);
				jedisClient.expireAt(ipCacheKey, calendar.getTime());
			}
		}
		catch (InvokeException e)
		{//短信发送失败
			smsSendLogData.setSendFlag(DictionaryConstants.BOL_FALSE);
			smsSendLogData.setDescription(e.getMessage());
			smsSendLogService.addSmsSendLog(smsSendLogData);
			throw e;
		}
		smsSendLogService.addSmsSendLog(smsSendLogData);
		return flag;
	}
	
	public static boolean hadSend(String sms_type, String mobile_no) throws InvokeException
	{
		boolean flag = false;
		CacheService cacheService = SpringHelper.getBean(BasicServiceBeanIdConstants.SERVICE_ID_CACHE, CacheService.class);
		String key = sms_type + "_" + mobile_no;
		//从缓存中获取验证码
		String saved_codetime = (String) cacheService.getCache(key);
		if (!StringHelper.isEmpty(saved_codetime)) //已存在该手机在该短信类型下的短信缓存
		{
			String codetime[] = saved_codetime.split("_");
			String sendTime = codetime[1];
			int sms_sendtime = Configuration.getInt("sms.smscodesend_time");
			String current_time = DateHelper.formatDate(new Date(), DateHelper.pattern_time);
			Date sendDate = DateHelper.parseString(sendTime, DateHelper.pattern_time);
			Date date = new Date();
			logger.info("date=" + current_time);
			long time_space = (date.getTime() - sendDate.getTime()) / 1000L;
			logger.info("time_space=" + time_space);
			if (time_space < sms_sendtime)
			{ //规定时间内重复申请
				throw new BusinessException(ErrorCodeSystem.SMS_ERROR_HASSENT);
			}
		}
		return flag;
	}
	
	/**
	 * 描述：获取短信模版
	 * @author 刘恺
	 * @created 2015年9月23日 下午2:18:55
	 * @since 
	 * @param smsType   短信模版类型，不同业务办理模版不同
	 * @param sendType	短信发送类型，同一个模版 不同情况下发送的类型不同
	 * @return
	 */
	public static SmsModelModel getSmsModel(String smsType, String sendType)
	{
		SmsModelService smsModelService = SpringHelper.getBean(BusinessServiceBeanIdConstants.SERVICE_ID_SMSMODEL, SmsModelService.class);
		SmsModelModel smsModelModel = smsModelService.queryModelByType(smsType, sendType);
		if (smsModelModel == null)
		{
			throw new BusinessException(ErrorCodeSystem.SMS_ERROR_NOMODEL);
		}
		return smsModelModel;
	}
	
	/**
	 * 描述:根据关键字和短信模版文本，获取发送的短信信息
	 * @author 刘恺
	 * @created 2015年9月23日 下午2:17:23
	 * @since 
	 * @param modelMsg 短信模版文本
	 * @param keyWords 关键字  key为替换的字段，value为替换后的文字
	 * @return
	 */
	public static String getSendMsg(String modelMsg, Map<String, String> keyWords)
	{
		for (Entry<String, String> item : keyWords.entrySet())
		{
			String key = item.getKey();
			String value = item.getValue();
			modelMsg = modelMsg.replace("@" + key, value);
		}
		return modelMsg;
	}
	
	/**
	 * 描述：根据短信类型发送短信
	 * @author 刘恺
	 * @created 2015年9月23日 下午2:30:01
	 * @since 
	 * @param smsType   短信模版类型，不同业务办理模版不同
	 * @param sendType	短信发送类型，同一个模版 不同情况下发送的类型不同
	 * @param keyWords	关键字  key为替换的字段，value为替换后的蚊子
	 * @return
	 * @throws Exception 
	 */
	public static DataRow sendByType(String smsType, String sendType, Map<String, String> keyWords, String mobile, Long user_id, String business_id, String ip, String mac,String business_code) throws Exception
	{
		//校验当前发送次数
		//缓存发送次数 前缀+用户编号+短信类型
		String userIdCacheKey = "ismp|smssend|" + user_id + "|" + smsType;
		JedisClient jedisClient = new JedisClient("web");
		//查询用户当前短信类型发送次数
		String userCurrSendTimeString = jedisClient.getString(userIdCacheKey);
		Long userCurrSendTime = 0L;
		if (StringUtils.isNotBlank(userCurrSendTimeString))
		{
			userCurrSendTime = Long.parseLong(userCurrSendTimeString);
			int maxSendInput = Configuration.getInt(SystemConstants.CONFIG_KEY_SMS_USERBUSINESSSENDMAX);
			Long leaveTime = maxSendInput - userCurrSendTime;
			if (leaveTime <= 0)
			{
				throw new BusinessException(ErrorCodeSystem.SMS_ERROR_OUTTIMES);
			}
		}
		//查询IP当前短信类型发送次数
		String ipCacheKey = "ismp|smssend|" + ip + "|" + smsType;
		String ipCurrSendTimeString = jedisClient.getString(ipCacheKey);
		Long ipCurrSendTime = 0L;
		if (StringUtils.isNotBlank(ipCurrSendTimeString))
		{
			ipCurrSendTime = Long.parseLong(ipCurrSendTimeString);
			int maxSendInput = Configuration.getInt(SystemConstants.CONFIG_KEY_SMS_IPBUSINESSSENDMAX);
			Long leaveTime = maxSendInput - ipCurrSendTime;
			if (leaveTime <= 0)
			{
				throw new BusinessException(ErrorCodeSystem.SMS_ERROR_OUTTIMES);
			}
		}
		
		SmsModelModel smsModel = getSmsModel(smsType, sendType);
		String state = smsModel.getState();
		//如果短信无效，则不发送短信
		if (!DictionaryConstants.BOL_TRUE.equals(state))
		{
			return smsModel;
		}
		smsModel.setSmsMessage(getSendMsg(smsModel.getSmsMessage(), keyWords));
		smsModel.set("sms_code", keyWords.get("verificationcode"));//验证码
		SmsUtils.sendByModel(smsModel, mobile, user_id, business_id, ip, mac,business_code);
		return smsModel;
	}
}
