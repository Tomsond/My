package com.thinkive.fxc.ismp.bus.business.util;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.security.InvalidKeyException;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.Security;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;

import com.thinkive.base.util.Base64Helper;

/** 
 * @author JavaDigest 
 *  
 */
public class EncryptionUtil
{ 
    
    /** 
     * String to hold name of the encryption algorithm. 
     */
    public static final String ALGORITHM        = "RSA";
    
    /** 
     * String to hold name of the encryption padding. 
     */
    public static final String PADDING          = "RSA/NONE/NoPadding";
    
    /** 
     * String to hold name of the security provider. 
     */
    public static final String PROVIDER         = "BC";
    
    /** 
     * String to hold the name of the private key file. 
     */
    public static final String PRIVATE_KEY_FILE = "E:/code/AndroidProject/keystore/private.key";
    
    /** 
     * String to hold name of the public key file. 
     */
    public static final String PUBLIC_KEY_FILE  = "E:/code/AndroidProject/keystore/public.key";
    
    /** 
     * Generate key which contains a pair of private and public key using 1024 
     * bytes. Store the set of keys in Prvate.key and Public.key files. 
     *  
     * @throws NoSuchAlgorithmException 
     * @throws IOException 
     * @throws FileNotFoundException 
     */
    public static void generateKey()
    {
        try
        {
            
            Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
            final KeyPairGenerator keyGen = KeyPairGenerator.getInstance(ALGORITHM, PROVIDER);
            keyGen.initialize(256);
            final KeyPair key = keyGen.generateKeyPair();
            
            File privateKeyFile = new File(PRIVATE_KEY_FILE);
            File publicKeyFile = new File(PUBLIC_KEY_FILE);
            
            // Create files to store public and private key  
            if ( privateKeyFile.getParentFile() != null )
            {
                privateKeyFile.getParentFile().mkdirs();
            }
            privateKeyFile.createNewFile();
            
            if ( publicKeyFile.getParentFile() != null )
            {
                publicKeyFile.getParentFile().mkdirs();
            }
            publicKeyFile.createNewFile();
            
            // Saving the Public key in a file  
            ObjectOutputStream publicKeyOS = new ObjectOutputStream(new FileOutputStream(publicKeyFile));
            publicKeyOS.writeObject(key.getPublic());
            publicKeyOS.close();
            
            // Saving the Private key in a file  
            ObjectOutputStream privateKeyOS = new ObjectOutputStream(new FileOutputStream(privateKeyFile));
            privateKeyOS.writeObject(key.getPrivate());
            privateKeyOS.close();
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
        
    }
    
    /** 
     * The method checks if the pair of public and private key has been 
     * generated. 
     *  
     * @return flag indicating if the pair of keys were generated. 
     */
    public static boolean areKeysPresent()
    {
        
        File privateKey = new File(PRIVATE_KEY_FILE);
        File publicKey = new File(PUBLIC_KEY_FILE);
        
        if ( privateKey.exists() && publicKey.exists() )
        {
            return true;
        }
        return false;
    }
    
    /** 
     * Encrypt the plain text using public key. 
     *  
     * @param text 
     *            : original plain text 
     * @param key 
     *            :The public key 
     * @return Encrypted text 
     * @throws java.lang.Exception 
     */
    public static byte[] encrypt(String text, PublicKey key)
    {
        byte[] cipherText = null;
        try
        {
            // get an RSA cipher object and print the provider  
            Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
            final Cipher cipher = Cipher.getInstance(PADDING, PROVIDER);
            
            // encrypt the plain text using the public key  
            cipher.init(Cipher.ENCRYPT_MODE, key);
            cipherText = cipher.doFinal(text.getBytes());
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
        return cipherText;
    }
    
    public static byte[] encrypt(String text, byte[] key)
    {
        byte[] cipherText = null;
        try
        {
            // 得到公钥对象
            X509EncodedKeySpec keySpec = new X509EncodedKeySpec(key);
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");
            PublicKey pubKey = keyFactory.generatePublic(keySpec);
            
            // get an RSA cipher object and print the provider
            Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
            final Cipher cipher = Cipher.getInstance(PADDING, PROVIDER);
            
            // encrypt the plain text using the public key
            cipher.init(Cipher.ENCRYPT_MODE, pubKey);
            cipherText = cipher.doFinal(text.getBytes());
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
        return cipherText;
    }
    
    /** 
     * Decrypt text using private key. 
     *  
     * @param text 
     *            :encrypted text 
     * @param key 
     *            :The private key 
     * @return plain text 
     */
    public static String decrypt(byte[] text, PrivateKey key)
    {
        byte[] dectyptedText;
        try
        {
            // get an RSA cipher object and print the provider  
            Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
            final Cipher cipher = Cipher.getInstance(PADDING, PROVIDER);
            
            // decrypt the text using the private key  
            cipher.init(Cipher.DECRYPT_MODE, key);
            dectyptedText = cipher.doFinal(text);
            
            return new String(dectyptedText);
        }
        catch (Exception ex)
        {
            ex.printStackTrace();
        }
        
        return null;
    }
    
    public static String decrypt(byte[] text, byte[] key) throws InvalidKeyException, NoSuchAlgorithmException,
            NoSuchProviderException, NoSuchPaddingException, InvalidKeySpecException, IllegalBlockSizeException,
            BadPaddingException{
        byte[] dectyptedText;
        // 得到私钥对象
        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(key);
        KeyFactory kf = KeyFactory.getInstance(ALGORITHM);
        PrivateKey keyPrivate = kf.generatePrivate(keySpec);
        
        // get an RSA cipher object and print the provider
        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
        final Cipher cipher = Cipher.getInstance(PADDING, PROVIDER);
        
        // decrypt the text using the private key
        cipher.init(Cipher.DECRYPT_MODE, keyPrivate);
        dectyptedText = cipher.doFinal(text);
        
        return new String(dectyptedText);
        
    }
    
    
    public static String decrypt(String text, String privateKey) throws InvalidKeyException, NoSuchAlgorithmException,NoSuchProviderException, NoSuchPaddingException, InvalidKeySpecException, IllegalBlockSizeException,BadPaddingException{
        // 得到私钥对象
        byte[]  key=Base64Helper.decode(privateKey);
        byte[]  textArray=Base64Helper.decode(text);
        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(key);
        KeyFactory kf = KeyFactory.getInstance(ALGORITHM);
        PrivateKey keyPrivate = kf.generatePrivate(keySpec); 
        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
        final Cipher cipher = Cipher.getInstance(PADDING, PROVIDER); 
        cipher.init(Cipher.DECRYPT_MODE, keyPrivate); 
        byte[] dectyptedText = cipher.doFinal(textArray); 
        return new String(dectyptedText);  
    }
    
    
    /** 
     * Test the EncryptionUtil 
     */
    public static void main(String[] args){
        
        try{
            final String originalText = "17017511126";
            
            String key1 = "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDDgdzHijVZJYpFwClgQg1ceIwd"
                    + "1FJz1/XErzIXAFMprxiGmw5G6JmcOJD2bi+YbRfGdUv9v2K/zA8eIlB9pcKDBwpy"
                    + "7eCFr2Hl4NTBUgWB/b+n3Fah5wrGdRSYeYScI6tYaoC5/1gpliUubMpUSNbeEFRX" + "tTj4GTDUAbIwd9uDlwIDAQAB";
            
            byte[] key = Base64Helper.decode(key1);
            
            // use String to hold cipher binary data
            String cipherTextBase64 = Base64Helper.encode(encrypt(originalText, key));
            
            // get cipher binary data back from String
            byte[] cipherTextArray = Base64Helper.decode(cipherTextBase64);
            
            String key2 = "MIICdQIBADANBgkqhkiG9w0BAQEFAASCAl8wggJbAgEAAoGBAMOB3MeKNVklikXA"
                    + "KWBCDVx4jB3UUnPX9cSvMhcAUymvGIabDkbomZw4kPZuL5htF8Z1S/2/Yr/MDx4i"
                    + "UH2lwoMHCnLt4IWvYeXg1MFSBYH9v6fcVqHnCsZ1FJh5hJwjq1hqgLn/WCmWJS5s"
                    + "ylRI1t4QVFe1OPgZMNQBsjB324OXAgMBAAECgYAC5AOoq6F4TPbLazjxZGigKmQf"
                    + "+MizT8khfFmoP2f7YMxjCR3f7IaA6dEy45Quk8ZbN9bEzLSgE1tR3b4E7ZN/p8th"
                    + "ppoPjNjAPhEyMURBoi0twXeMALqZkrtHUDUWRxhXk9aQ9MJcJdi8+S+KcYh+cZdQ"
                    + "MB3bR26vqVDiMtMk0QJBAP00IM7Qhm0F9YGVibDSDqaL78+Zn5vSfg0B1Li24YXq"
                    + "69rDyvhpQN4qThr4+J/enaPD+TT6nkB5XlhnmijJ7xkCQQDFqpygl3yCekwYEGMZ"
                    + "Se7d/QyvIpkSycWLg4/X8lK90a7TVSlTup+/aExktCGEytEtfJ0AGYYndFSjEi3E"
                    + "R04vAkBzFiqDVkyDaV35lFqNQCzgjmJl3dGqJbadeuORQa6oC+s/+BZdapnNYTU3"
                    + "FUsMf0bvlLfE2NTtQT0cuZpcR8yhAkAB5B75flmHmgnuVQHNtSJe51PevRL/1gRY"
                    + "0Fpo832NKVtl1DPABFIQ77uDXyHO9m3H5KBP5u6cpAVHRh4/+XqrAkBUhvxCppy1"
                    + "mHLfucNNAJ4QAUb3C95sW26dsWUHlSdH6weZpMYEDaJFBxm1RVP2y8Avgg73GqKp" + "81x0p5iZ3may";
            key = Base64Helper.decode(key2);
            
            final String plainText = decrypt(cipherTextArray, key);
            
            // Printing the Original, Encrypted and Decrypted Text
            System.out.println("Original=" + originalText);
            System.out.println("Encrypted=" + cipherTextBase64);
            System.out.println("Decrypted=" + plainText);
            
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
